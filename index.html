<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Animation Demo</title>
    <style>
        /* Basic page styling */
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 3rem;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }

        .container {
            text-align: center;
        }

        .label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        /* The animated text element */
        .question {
            font-size: 2rem;
            color: #333;

            /* ===== ANIMATION PROPERTIES ===== */

            /* animation-name: References the @keyframes rule below */
            animation-name: slideFromRight;

            /* animation-duration: How long the animation takes (in seconds or milliseconds) */
            animation-duration: 1.5s;

            /* animation-timing-function: Controls the speed curve
               - ease-out: Starts fast, slows down at the end (natural feeling)
               - Other options: linear, ease, ease-in, ease-in-out, cubic-bezier() */
            animation-timing-function: ease-out;

            /* animation-fill-mode: What happens AFTER the animation finishes
               - forwards: Keeps the final state (stays at translateX(0))
               - backwards: Applies first keyframe DURING delay period
               - both: Combines backwards + forwards (see examples below!)
               Without this, the text would snap back to off-screen! */
            animation-fill-mode: forwards;

            /* SHORTHAND: You can combine all the above into one line:
               animation: slideFromRight 1.5s ease-out forwards; */
        }

        /* ===== KEYFRAMES DEFINITION ===== */
        /* @keyframes defines the animation sequence
           Think of it like: "from this state... to that state"
           You can also use percentages: 0%, 50%, 100% for multi-step animations */
        @keyframes slideFromRight {
            /* Starting state: positioned off-screen to the right */
            from {
                /* transform: translateX() moves elements horizontally
                   - Positive values = move right
                   - Negative values = move left
                   - 100vw = 100% of viewport width (entire screen width)

                   WHY transform instead of 'left' or 'margin-left'?
                   - GPU-accelerated = smoother, 60fps animations
                   - Doesn't trigger layout recalculation = better performance
                   - Can combine multiple transforms (translate, scale, rotate) */
                transform: translateX(100vw);

                /* Optional: You can also animate opacity for a fade-in effect */
                /* opacity: 0; */
            }

            /* Ending state: at its natural position in the center */
            to {
                /* translateX(0) means "no horizontal offset" = original position */
                transform: translateX(0);

                /* opacity: 1; */
            }
        }

        /* ===== DELAY EXAMPLES ===== */
        /* These demonstrate the difference between 'forwards' and 'both' with animation-delay */

        .delayed-forwards {
            font-size: 1.5rem;
            color: #e63946;
            animation-name: slideFromRight;
            animation-duration: 1s;
            animation-delay: 2s;  /* ← Wait 2 seconds before animating */
            animation-timing-function: ease-out;
            animation-fill-mode: forwards;

            /* WATCH: During the 2-second delay, this text appears at CENTER (its natural position)
               Then after 2s, it suddenly jumps off-screen-right and slides back to center.
               WHY? Because 'forwards' only affects AFTER the animation, not during the delay. */
        }

        .delayed-both {
            font-size: 1.5rem;
            color: #2a9d8f;
            animation-name: slideFromRight;
            animation-duration: 1s;
            animation-delay: 2s;  /* ← Same delay */
            animation-timing-function: ease-out;
            animation-fill-mode: both;

            /* WATCH: During the 2-second delay, this text is ALREADY off-screen-right
               (positioned at the first keyframe: translateX(100vw))
               Then after 2s, it smoothly slides to center.
               WHY? Because 'both' = 'backwards' + 'forwards'
               - 'backwards' = apply first keyframe during delay
               - 'forwards' = keep last keyframe after animation */
        }

        /* EXPERIMENT: Try changing these values to see how they affect the animation:
           1. animation-duration: Try 0.5s (fast) or 3s (slow)
           2. animation-timing-function: Try 'linear' or 'ease-in'
           3. In @keyframes from: Try translateX(50vw) or translateX(-100vw)
           4. Add more keyframe steps:
              @keyframes slideFromRight {
                  0% { transform: translateX(100vw); }
                  50% { transform: translateX(-50px); } // slight overshoot
                  100% { transform: translateX(0); }
              }
        */
    </style>
</head>
<body>
    <div class="container">
        <div class="label">No delay - starts immediately</div>
        <div class="question">
            What is your favorite programming language?
        </div>
    </div>

    <div class="container">
        <div class="label">2s delay + fill-mode: forwards (jumps during delay)</div>
        <div class="delayed-forwards">
            This appears at CENTER first, then jumps and slides
        </div>
    </div>

    <div class="container">
        <div class="label">2s delay + fill-mode: both (smooth from start)</div>
        <div class="delayed-both">
            This starts off-screen immediately, then slides smoothly
        </div>
    </div>
</body>
</html>
