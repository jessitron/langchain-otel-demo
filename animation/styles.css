/* ===== LOCAL FONT LOADING ===== */
/* @font-face tells the browser to load a font from your computer/project
           You can reference this font by its font-family name anywhere in your CSS */
@font-face {
  font-family: "Tenor Sans";
  src: url("./fonts/TenorSans-Regular.ttf") format("truetype");
  font-weight: normal;
}

/* Basic page styling */
body {
  margin: 0;
  padding: 0;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: "Tenor Sans", sans-serif;
  background-color: #f0f0f0;
}

/* The animated text element */
.question span {
  display: inline-block; /* Required for transforms to work! */
  font-size: 2rem;
  color: #333;

  /* ===== TRANSFORM ORIGIN ===== */
  /* This sets the pivot point for rotations
     - default is 'center center' (50% 50%)
     - 'left center' means rotate around the left edge vertically centered */
  transform-origin: left center;

  /* ===== ANIMATION PROPERTIES ===== */
  /* Animation will be triggered by JavaScript, not on page load */

  /* animation-duration: How long the animation takes (in seconds or milliseconds)
               We increased this to 3s to accommodate our three-phase animation:
               - 0% → 50% (1.5s): Slide in from right
               - 50% (instant): Rotate 90deg
               - 50% → 100% (1.5s): Move down */

  /* animation-timing-function: Controls the speed curve
               - ease-out: Starts fast, slows down at the end (natural feeling)
               - Other options: linear, ease, ease-in, ease-in-out, cubic-bezier() */
  animation-timing-function: ease-out;

  /* animation-fill-mode: What happens AFTER the animation finishes
               - forwards: Keeps the final state (stays at translateX(0))
               - backwards: Returns to original state
               - both: Applies both forwards and backwards
               Without this, the text would snap back to off-screen! */
  animation-fill-mode: forwards;

  /* SHORTHAND: You can combine all the above into one line:
               animation: slideFromRight 1.5s ease-out forwards; */
}

/* Class to trigger "What" animation */
.question span.animate-what {
  animation-duration: 3s;
  animation-name: slideFromRight;
}

/* Class to trigger "is" animation - will use JS to set the translateX value */
.question span.animate-is {
  animation-duration: 3.6s;
  animation-name: slideFromRightIs;
  /* animation-delay: How long to wait before starting the animation
     - 0.5s means "is" will wait half a second before starting
     - Try different values like 0.2s, 1s, etc. */
}

/* ===== KEYFRAMES DEFINITION ===== */
/* @keyframes with MULTIPLE STEPS for sequential animations
           Using percentages (0%, 50%, 100%) lets us create complex motion sequences */
@keyframes slideFromRight {
  /* PHASE 1 (0% → 50%): Slide in from the right */
  0% {
    /* Starting position: off-screen to the right */
    transform: translateX(100vw);
  }

  /* PHASE 2 (50%): At center, rotate 90 degrees counterclockwise */
  40% {
    transform: translateX(0);
  }
  60% {
    /* COMBINING TRANSFORMS: Multiple transforms in ONE property
                   - translateX(0): Move to center position
                   - rotate(-90deg): Rotate 90 degrees counterclockwise
                     (negative = counterclockwise, positive = clockwise)

                   IMPORTANT: Order matters when combining transforms!
                   - translate THEN rotate: rotation happens around original axis
                   - rotate THEN translate: translation follows rotated axis

                   Here we translate first, then rotate, so the text rotates
                   in place at the center */
    transform: rotate(-90deg);
  }

  /* PHASE 3 (50% → 100%): Move downward */
  100% {
    /* After rotation, we add vertical translation
          - translateY(40vh): Move down 40% of viewport height
          - rotate(-90deg): Keep the rotation

                   Notice we MUST repeat rotate(-90deg) here!
                   If we don't, the text would rotate back to 0deg while moving down.
                   Each keyframe defines the COMPLETE state at that moment
                   
                   Also it's important to do translateY before rotate(-90deg)
                   because we don't want the translation to happen along the rotated axis */
    transform: translateY(40vh) rotate(-90deg);
  }
}

/* Animation for "is" - uses CSS variable for the final translateX position */
@keyframes slideFromRightIs {
  /* PHASE 1 (0% → 40%): Slide in from the right */
  0% {
    transform: translateX(100vw);
  }

  /* PHASE 2 (40%): Stop at the same x-coordinate as "What" */
  40% {
    /* This will be set dynamically by JavaScript */
    transform: translateX(var(--is-offset, 0px));
  }
  60% {
    /* Rotate 90 degrees counterclockwise */
    transform: translateX(var(--is-offset, 0px)) rotate(-90deg);
  }

  /* PHASE 3 (60% → 100%): Move downward */
  100% {
    transform: translateX(var(--is-offset, 0px)) translateY(40vh) rotate(-90deg);
  }
}

/* EXPERIMENT: Try changing these values to see how they affect the animation:
           1. animation-duration: Try 0.5s (fast) or 3s (slow)
           2. animation-timing-function: Try 'linear' or 'ease-in'
           3. In @keyframes from: Try translateX(50vw) or translateX(-100vw)
           4. Add more keyframe steps:
              @keyframes slideFromRight {
                  0% { transform: translateX(100vw); }
                  50% { transform: translateX(-50px); } // slight overshoot
                  100% { transform: translateX(0); }
              }
        */
